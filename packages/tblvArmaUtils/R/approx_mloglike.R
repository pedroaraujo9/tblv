#' Apprimation of the marginal likelihood for btblv models
#'
#' @param btblv_posterior `btblv_posterior` generated by `btblv::extract_posterior`.
#' @param N numeric value with the Monte Carlo sample size.
#' @param seed integer value with seed for the random generating system.
#' @param cores integer value with the number of cores used for the computation. Default is 1
#'
#' @return object of the class `btblv_approx_mloglike`.
#' @export
#'
#' @examples
#' # 
approx_mloglike = function(btblv_posterior, N, seed, cores = 1) {
  
  post_summ = btblv_posterior |> btblv::posterior_summary()
  btblv_data = btblv_posterior$btblv_data

  data_wide = btblv_data$data_wide
  
  data_matrix = btblv_data$data_list_stan$x
  K = btblv_data$data_list_stan$K
  Ng = btblv_data$data_list_stan$Ng
  
  alpha = post_summ$posterior_mean$alpha
  beta = post_summ$posterior_mean$beta
  kappa = post_summ$posterior_mean$kappa
  
  if(btblv_posterior$precision == "single") {
    kappa = kappa * (beta/beta)
  }
  
  set.seed(seed)
  
  if(cores == 1) {
    mloglike = foreach::foreach(g=1:Ng, .combine = "c") %do% {
      cat(g, "\r")
      
      inds = data_wide |>
        dplyr::filter(group_num == g) |> 
        dplyr::select(ind_num) |> 
        base::unlist() 
      
      data_group = data_matrix[inds, ]
      
      phi = post_summ$posterior_mean$phi[g, 1]
      sigma = post_summ$posterior_mean$sigma[g, 1]
      
      E_post_sample_list = lapply(inds, function(i){
        cbind(btblv_posterior$post_sample_array$rot_E[, i, ])
      })
      
      log_mlike_sample = tblvArmaUtils::rcpp_mc_log_mlike(
        N=N, 
        x = data_group, 
        alpha = alpha, 
        beta = beta, 
        kappa = kappa, 
        phi = phi,
        sigma = sigma, 
        E_post_sample_list = E_post_sample_list
      )
      
      tblvArmaUtils::LSE(log_mlike_sample) - log(N)
    }
    
  }else{
    
    pkgs = c("dplyr", "Rcpp", "tblvArmaUtils")
    funcs = c("mc_log_mlike")
    
    cl = parallel::makeCluster(cores)  
    doParallel::registerDoParallel(cl)  
    
    mloglike = foreach::foreach(g=1:Ng, .combine = "c") %do% {
      
      inds = data_wide |>
        dplyr::filter(group_num == g) |> 
        dplyr::select(ind_num) |> 
        base::unlist() 
      
      data_group = data_matrix[inds, ]
      
      phi = post_summ$posterior_mean$phi[g, 1]
      sigma = post_summ$posterior_mean$sigma[g, 1]
      
      E_post_sample_list = lapply(inds, function(i){
        cbind(btblv_posterior$post_sample_array$rot_E[, i, ])
      })
      
      log_mlike_sample = tblvArmaUtils::rcpp_mc_log_mlike(
        N=N, 
        x = data_group, 
        alpha = alpha, 
        beta = beta, 
        kappa = kappa, 
        phi = phi,
        sigma = sigma, 
        E_post_sample_list = E_post_sample_list
      )
      
      tblvArmaUtils::LSE(log_mlike_sample) - log(N)
    }
    
    parallel::stopCluster(cl)
  }
  
  out = list(
    mloglike = mloglike,
    N = N,
    btblv_data = btblv_posterior$btblv_data,
    posterior_mean = post_summ$posterior_mean,
    E_posterior_sample = btblv_posterior$post_sample_array$rot_E
  )
  
  class(out) = "btblv_approx_mloglike"
  
  return(out)
}

