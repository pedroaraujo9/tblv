#' Simulate matrix from a uniform distribution
#'
#' @param nrow number of rows
#' @param ncol number of cols
#' @param lower min
#' @param upper max
#'
#' @return random matrix
#'
#' @examples
#' # .simulate_uniform_matrix(ncol=2, nrow=100, lower=-1, upper=1)
.simulate_uniform_matrix = function(ncol, nrow, lower, upper) {
  m = matrix(runif(nrow*ncol, min = lower, max = upper), nrow = nrow, ncol = ncol)
  return(m)
}

#' Simualte matrix from normal distribution
#'
#' @param nrow number of rows
#' @param ncol number of cols
#' @param mu mean of the normal distribution
#' @param sigma standard deviation of the normal distribution
#'
#' @return random matrix
#'
#' @examples
#' # .simulate_normal_matrix(ncol=100, nrow=2, mu=10, sigma=3)
.simulate_normal_matrix = function(ncol, nrow, mu, sigma) {
  m = matrix(rnorm(nrow*ncol, mean = mu, sd = sigma), nrow = nrow, ncol = ncol)
  return(m)
}

#' Generate init values for the MCMC chains
#'
#' @param btblv_data object of class btblv_data with data information
#' @param K integer with the latent dimension size
#' @param chains integer with number of chains
#' @param precision string with type of precision, `single` for one, `multiple` for multiple
#' @param seed integer with the random seed
#'
#' @return list of list with the initial values for each chain
#'
#' @examples
#'
.generate_init_values = function(btblv_data, K, chains, precision = "single", seed) {
  set.seed(seed)

  mle_fit = betareg::betareg(
    y ~ factor(item) - 1 | factor(item) - 1,
    data = btblv_data$data,
    link = "logit",
    link.phi = "log"
  )

  n = btblv_data$data_list_stan$n
  J = btblv_data$data_list_stan$J
  Ng = btblv_data$data_list_stan$Ng

  beta_mle = mle_fit$coefficients$mean
  precision_mle = mle_fit$coefficients$precision

  if(precision == "single") {
    init_list = purrr::map(1:chains, ~{
      list(
        E = simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        log_kappa = mean(precision_mle) + rnorm(n = 1, sd = 0.1)
      )
    })
  }else if(precision == "multiple"){
    init_list = purrr::map(1:chains, ~{
      list(
        E = simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        log_kappa = precision_mle + rnorm(n = 1, sd = 0.1)
      )
    })
  }

  return(init_list)

}

#' Compute the Procrustean matching rotation for each iteration of the posterior
#'
#' @param post_sample array with iters, param, latent dimension
#' @param reference_matrix reference matrix to match
#'
#' @return list with the Procrustean transform for each iteration
#'
#' @examples
#' #
.get_rotation = function(post_sample, reference_matrix) {
  rotation_list = list()
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = cbind(post_sample[i,,]),
                                             X = cbind(reference_matrix),
                                             scale = F)
    }
  }else{
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = post_sample[i,,],
                                             X = reference_matrix,
                                             scale = F)
    }
  }

  return(rotation_list)
}

#' Apply the Procrustean transformation for each element of the posterior
#'
#' @param post_sample array with iter, param, latent dimension
#' @param rotation_list list with Procrustean transform generated by .get_rotation
#'
#' @return array with the rotated posterior sample
#'
#' @examples
#' #
.apply_rotation = function(post_sample, rotation_list) {
  new_post_sample = post_sample
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = cbind(post_sample[i,,])%*%r
    }
  }else{
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = post_sample[i,,]%*%r
    }
  }

  return(new_post_sample)
}

