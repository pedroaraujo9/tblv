#' Simulate matrix from a uniform distribution
#'
#' @param nrow number of rows
#' @param ncol number of cols
#' @param lower min
#' @param upper max
#'
#' @return random matrix
#'
#' @examples
#' # .simulate_uniform_matrix(ncol=2, nrow=100, lower=-1, upper=1)
.simulate_uniform_matrix = function(ncol, nrow, lower, upper) {
  m = matrix(runif(nrow*ncol, min = lower, max = upper), nrow = nrow, ncol = ncol)
  return(m)
}

#' Simualte matrix from normal distribution
#'
#' @param nrow number of rows
#' @param ncol number of cols
#' @param mu mean of the normal distribution
#' @param sigma standard deviation of the normal distribution
#'
#' @return random matrix
#'
#' @examples
#' # .simulate_normal_matrix(ncol=100, nrow=2, mu=10, sigma=3)
.simulate_normal_matrix = function(ncol, nrow, mu, sigma) {
  m = matrix(rnorm(nrow*ncol, mean = mu, sd = sigma), nrow = nrow, ncol = ncol)
  return(m)
}

#' Generate init values for the MCMC chains
#'
#' @param btblv_data object of class btblv_data with data information
#' @param K integer with the latent dimension size
#' @param chains integer with number of chains
#' @param precision string with type of precision, `single` for one, `multiple` for multiple
#' @param seed integer with the random seed
#'
#' @return list of list with the initial values for each chain
#'
#' @examples
#'#
.generate_init_values = function(btblv_data, K, chains, precision = "single", seed) {
  set.seed(seed)

  mle_fit = betareg::betareg(
    y ~ factor(item) - 1 | factor(item) - 1,
    data = btblv_data$data,
    link = "logit",
    link.phi = "log"
  )

  n = btblv_data$data_list_stan$n
  J = btblv_data$data_list_stan$J
  Ng = btblv_data$data_list_stan$Ng

  beta_mle = mle_fit$coefficients$mean
  precision_mle = mle_fit$coefficients$precision

  if(precision == "single") {
    init_list = purrr::map(1:chains, ~{
      list(
        E = .simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = .simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        log_kappa = mean(precision_mle) + rnorm(n = 1, sd = 0.1)
      )
    })
  }else if(precision == "specific"){
    init_list = purrr::map(1:chains, ~{
      list(
        E = .simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = .simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        log_kappa = precision_mle + rnorm(n = 1, sd = 0.1)
      )
    })
  }

  return(init_list)

}

#' Compute the Procrustean matching rotation for each iteration of the posterior
#'
#' @param post_sample array with iters, param, latent dimension
#' @param reference_matrix reference matrix to match
#'
#' @return list with the Procrustean transform for each iteration
#'
#' @examples
#' #
.get_rotation = function(post_sample, reference_matrix) {
  rotation_list = list()
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = cbind(post_sample[i,,]),
                                             X = cbind(reference_matrix),
                                             scale = F)
    }
  }else{
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = post_sample[i,,],
                                             X = reference_matrix,
                                             scale = F)
    }
  }

  return(rotation_list)
}

#' Apply the Procrustean transformation for each element of the posterior
#'
#' @param post_sample array with iter, param, latent dimension
#' @param rotation_list list with Procrustean transform generated by .get_rotation
#'
#' @return array with the rotated posterior sample
#'
#' @examples
#' #
.apply_rotation = function(post_sample, rotation_list) {
  new_post_sample = post_sample
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = cbind(post_sample[i,,])%*%r
    }
  }else{
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = post_sample[i,,]%*%r
    }
  }

  return(new_post_sample)
}

#' Logit function
#'
#' @param x numeric value between 0, and 1
#'
#' @return logit of the numeric
#' @export
#'
#' @examples
#' # .logit(0.1)
logit = function(x) {
  log(x/(1-x))
}

#' Inverse of the logit function
#'
#' @param x numeric real value
#'
#' @return invese of the logit
#' @export
#'
#' @examples
#' # .inv_logit(10)
inv_logit = function(x) {
  1/(1+exp(-x))
}

#' Reshape non-permuted posterior to look similar to the shape of the permuted chains
#'
#' @param chain_array array of non-permuted chain generated by rstan::extrac(stan_fit, permuted = F)
#' @param param_name character with the name of the parameter you want to reshape
#' @param param_dims numeric with the dimension of the parameter you want to reshape
#'
#' @return list where each element is the posterior sample
#'
#' @examples
#' # .reshape_chain_posterior()
.reshape_chain_posterior = function(chain_array, param_name, param_dims) {
  iters = dim(chain_array)[1]
  chains = dim(chain_array)[2]
  param_names = colnames(chain_array[1,,])

  if(length(param_dims) == 2) {

    reshaped_array = array(NA, dim = c(iters, chains, param_dims))

    for(chain in 1:chains) {
      for(k in 1:param_dims[2]) {
        param_cols = stringr::str_detect(param_names, paste0("^", param_name, "\\[\\d{1,1000},", k, "\\]$"))
        sample = chain_array[, chain, param_cols]
        reshaped_array[, chain, , k] = cbind(sample)
      }
    }
  }else if(length(param_dims) == 1) {
    reshaped_array = array(NA, dim = c(iters, chains, param_dims))

    for(chain in 1:chains) {
      for(k in 1:param_dims[1]) {
        param_cols = stringr::str_detect(param_names, paste0("^", param_name, "\\[", k, "\\]$"))
        sample = chain_array[, chain, param_cols]
        reshaped_array[, chain, k] = cbind(sample)
      }
    }
  }else if(length(param_dims) == 0) {
    for(chain in 1:chains) {
      reshaped_array = chain_array[, chain, param_name]
    }
  }

  return(reshaped_array)
}

#' Compute posterior mean from posterior sample rstan array
#'
#' @param array array with posterior sample
#'
#' @return posterior mean
#'
#' @examples
#' #
.compute_posterior_mean = function(array) {
  array_dim = dim(array)

  if(length(array_dim) == 3) {
    post_mean = lapply(1:array_dim[3], function(k){
      array[,,k] %>% colMeans()
    }) %>%
      do.call(cbind, .)

  }else if(length(array_dim) == 2) {
    post_mean = colMeans(array) %>% cbind()
  }else if(length(array_dim) == 1) {
    post_mean = mean(array)
  }

  return(post_mean)
}

#' Preserve the last shape in an array with 3 dimensions
#'
#' @param array array with two dimensions (n, J)
#'
#' @return array with dimension (n, J, 1)
#'
#' @examples
#' #
.add_last_dimension = function(array) {
  array_dim = dim(array)
  new_array = array(dim = c(array_dim, 1))
  new_array[, , 1] = array
  return(new_array)
}
