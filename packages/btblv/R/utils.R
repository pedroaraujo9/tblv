#' Simulate matrix from a uniform distribution
#'
#' @param nrow number of rows.
#' @param ncol number of cols.
#' @param lower min.
#' @param upper max.
#'
#' @return numeric matrix.
#'
#' @examples
#' # .simulate_uniform_matrix(ncol=2, nrow=100, lower=-1, upper=1)
.simulate_uniform_matrix = function(ncol, nrow, lower, upper) {
  m = matrix(runif(nrow*ncol, min = lower, max = upper), nrow = nrow, ncol = ncol)
  return(m)
}

#' Simualte matrix from normal distribution
#'
#' @param nrow number of rows
#' @param ncol number of cols
#' @param mu mean of the normal distribution
#' @param sigma standard deviation of the normal distribution
#'
#' @return random matrix
#'
#' @examples
#' # .simulate_normal_matrix(ncol=100, nrow=2, mu=10, sigma=3)
.simulate_normal_matrix = function(ncol, nrow, mu, sigma) {
  m = matrix(rnorm(nrow*ncol, mean = mu, sd = sigma), nrow = nrow, ncol = ncol)
  return(m)
}

#' Generate init values for the MCMC chains for the btblv model
#'
#' @param btblv_data object of class btblv_data with data information.
#' @param K integer with the latent dimension size.
#' @param chains integer with number of chains.
#' @param precision string with type of precision, `single` for one, `multiple` for multiple.
#' @param seed integer with the random seed.
#'
#' @return list of list with the initial values for each chain.
#'
#' @examples
#'#
.generate_init_values = function(btblv_data, K, chains, precision = "single", seed) {
  set.seed(seed)

  mle_fit = betareg::betareg(
    y ~ factor(item) - 1 | factor(item) - 1,
    data = btblv_data$data,
    link = "logit",
    link.phi = "log"
  )

  n = btblv_data$data_list_stan$n
  J = btblv_data$data_list_stan$J
  Ng = btblv_data$data_list_stan$Ng

  beta_mle = mle_fit$coefficients$mean
  precision_mle = mle_fit$coefficients$precision

  if(precision == "single") {
    init_list = purrr::map(1:chains, ~{
      list(
        E = .simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = .simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        log_kappa = mean(precision_mle) + rnorm(n = 1, sd = 0.1)
      )
    })
  }else if(precision == "specific"){
    init_list = purrr::map(1:chains, ~{
      list(
        E = .simulate_normal_matrix(nrow = n, ncol = K, mu = 0, sigma = 0.1),
        alpha = .simulate_normal_matrix(nrow = J, ncol = K, mu = 0, sigma = 0.1),
        beta = beta_mle + rnorm(n=J, sd = 0.1),
        log_sigma = rnorm(Ng, 0, 0.1),
        phi = runif(Ng, -0.1, 0.1),
        baseline_delta = mean(precision_mle) + rnorm(n = 1, sd = 0.1),
        delta_raw = precision_mle[-J] - mean(precision_mle) + rnorm(n = 1, sd = 0.1)
      )
    })
  }

  return(init_list)

}

#' Compute the Procrustean matching rotation for each iteration of the posterior
#'
#' @param post_sample array with iters, param, latent dimension.
#' @param reference_matrix numeric matrix with reference to match.
#'
#' @return list with the Procrustean transform for each iteration.
#'
#' @examples
#' #
.get_rotation = function(post_sample, reference_matrix) {
  rotation_list = list()
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = cbind(post_sample[i,,]),
                                             X = cbind(reference_matrix),
                                             scale = F)
    }
  }else{
    for(i in 1:iters) {
      rotation_list[[i]] = vegan::procrustes(Y = post_sample[i,,],
                                             X = reference_matrix,
                                             scale = F)
    }
  }

  return(rotation_list)
}

#' Apply the Procrustean transformation for each element of the posterior
#'
#' @param post_sample array with iter, param, latent dimension.
#' @param rotation_list list with Procrustean transform generated by `.get_rotation`.
#'
#' @return array with the rotated posterior sample.
#'
#' @examples
#' #
.apply_rotation = function(post_sample, rotation_list) {
  new_post_sample = post_sample
  iters = dim(post_sample)[1]
  K = dim(post_sample)[3]

  if(K == 1) {
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = cbind(post_sample[i,,])%*%r
    }
  }else{
    for(i in 1:iters) {
      r = rotation_list[[i]]$rotation
      new_post_sample[i,,] = post_sample[i,,]%*%r
    }
  }

  return(new_post_sample)
}

#' Logit function
#'
#' @param x numeric value between 0, and 1.
#'
#' @return logit of the numeric.
#' @export
#'
#' @examples
#' logit(0.1)
logit = function(x) {
  log(x/(1-x))
}

#' Inverse of the logit function
#'
#' @param x numeric value.
#'
#' @return numeric value inverse of the logit.
#' @export
#'
#' @examples
#' inv_logit(10)
inv_logit = function(x) {
  1/(1+exp(-x))
}

#' Reshape non-permuted posterior to look similar to the shape of the permuted chains
#'
#' @param chain_array array of non-permuted chain generated by `rstan::extrac(stan_fit, permuted = F)`.
#' @param param_name character with the name of the parameter you want to reshape.
#' @param param_dims numeric with the dimension of the parameter you want to reshape.
#'
#' @return list where each element is the posterior sample.
#'
#' @examples
#' # .reshape_chain_posterior()
.reshape_chain_posterior = function(chain_array, param_name, param_dims) {
  iters = dim(chain_array)[1]
  chains = dim(chain_array)[2]
  param_names = colnames(chain_array[1,,])

  if(length(param_dims) == 2) {

    reshaped_array = array(NA, dim = c(iters, chains, param_dims))

    for(chain in 1:chains) {
      for(k in 1:param_dims[2]) {
        param_cols = stringr::str_detect(param_names, paste0("^", param_name, "\\[\\d{1,1000},", k, "\\]$"))
        sample = chain_array[, chain, param_cols]
        reshaped_array[, chain, , k] = cbind(sample)
      }
    }
  }else if(length(param_dims) == 1) {
    reshaped_array = array(NA, dim = c(iters, chains, param_dims))

    for(chain in 1:chains) {
      for(k in 1:param_dims[1]) {
        param_cols = stringr::str_detect(param_names, paste0("^", param_name, "\\[", k, "\\]$"))
        sample = chain_array[, chain, param_cols]
        reshaped_array[, chain, k] = cbind(sample)
      }
    }
  }else if(length(param_dims) == 0) {
    reshaped_array = array(dim = c(iters, chains))

    for(chain in 1:chains) {
      reshaped_array[, chain] = chain_array[, chain, param_name]
    }
  }

  return(reshaped_array)
}

#' Compute posterior mean from posterior sample rstan array
#'
#' @param array array with posterior sample.
#'
#' @return posterior mean.
#'
#' @examples
#' #
.compute_posterior_mean = function(array) {
  array_dim = dim(array)

  if(length(array_dim) == 3) {
    post_mean = lapply(1:array_dim[3], function(k){
      array[,,k] %>% colMeans()
    }) %>%
      do.call(cbind, .)

  }else if(length(array_dim) == 2) {
    post_mean = colMeans(array) %>% cbind()
  }else if(length(array_dim) == 1) {
    post_mean = mean(array)
  }

  return(post_mean)
}

#' Preserve the last shape in an array with 3 dimensions
#'
#' @param array array with two dimensions (n, J)
#'
#' @return array with dimension (n, J, 1)
#'
#' @examples
#' #
.add_last_dimension = function(array) {
  array_dim = dim(array)
  new_array = array(dim = c(array_dim, 1))
  new_array[, , 1] = array
  return(new_array)
}


#' Generate data.frame with posterior summaries
#'
#' @param post_array array with posterior generated by `rstan`.
#' @param cred_mass credible interval mass. Default is 0.95.
#'
#' @return data.frame with posterior summaries.
#'
#' @examples
#' #
.get_summary_df = function(post_array, cred_mass = 0.95) {
  array_dim = dim(post_array)

  if(length(array_dim) == 3) {
    post_summary = lapply(1:array_dim[3], function(k){
      post_array[,,k] %>%
        as.data.frame() %>%
        dplyr::mutate(iter = 1:nrow(.)) %>%
        tidyr::gather(id, value, -iter) %>%
        dplyr::mutate(K = k)
    }) %>%
      do.call(rbind, .) %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = stringr::str_remove(id, "V") %>% as.integer()) %>%
      dplyr::group_by(id, K) %>%
      dplyr::summarise(mean = mean(value),
                       sd = sd(value),
                       li = HDInterval::hdi(value, credMass = cred_mass)[1],
                       median = median(value),
                       ui = HDInterval::hdi(value, credMass = cred_mass)[2]) %>%
      ungroup()

  }else if(length(array_dim) == 2){
    post_summary = post_array %>%
      as.data.frame() %>%
      dplyr::mutate(iter = 1:nrow(.)) %>%
      tidyr::gather(id, value, -iter) %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = stringr::str_remove(id, "V") %>% as.integer()) %>%
      dplyr::group_by(id) %>%
      dplyr::summarise(mean = mean(value),
                       sd = sd(value),
                       li = HDInterval::hdi(value, credMass = cred_mass)[1],
                       median = median(value),
                       ui = HDInterval::hdi(value, credMass = cred_mass)[2]) %>%
      ungroup()

  }else if(length(array_dim) == 1) {
    value = post_array
    post_summary = data.frame(
      mean = mean(value),
      sd = sd(value),
      li = HDInterval::hdi(value, credMass = cred_mass)[1] %>% as.numeric(),
      median = median(value),
      ui = HDInterval::hdi(value, credMass = cred_mass)[2] %>% as.numeric()
    )
  }

  return(post_summary)
}

#' Compute converge checks for a posterior sample
#'
#' Computes the Rhat, ESS and ESS bulk for a posterior sample.
#' @param array array with dimension (iters, chains, ...).
#'
#' @return data.frame with the metrics and id for first dimension, k for the second.
#'
#' @examples
#' #
.compute_converge_metrics = function(array) {
  array_dim = dim(array)

  # for one dim parameters
  if(length(array_dim) == 2){

    conv_check_metrics = data.frame(
      rhat = posterior::rhat(array),
      ess = posterior::ess_basic(array)
    )
    # for two dimensional parameters
  }else if(length(array_dim) == 3){

    conv_check_metrics = lapply(1:array_dim[3], function(j){
      data.frame(
        id = j,
        rhat = posterior::rhat(array[, , j]),
        ess = posterior::ess_basic(array[, , j]),
        ess_bulk = posterior::ess_bulk(array[, , j])
      )
    }) %>%
      do.call(rbind, .)
    # for three dimensional parameters
  }else if(length(array_dim) == 4) {
    # check if the last dimension is one, it changes the shape of the array when subseted
    if(array_dim[4] == 1) {
      conv_check_metrics = lapply(1:array_dim[3], function(j){
        data.frame(
          id = j,
          K = 1,
          rhat = posterior::rhat(array[, , j, 1]),
          ess = posterior::ess_basic(array[, , j, 1]),
          ess_bulk = posterior::ess_bulk(array[, , j, 1])
        )
      }) %>%
        do.call(rbind, .)

      # regular case
    }else{
      conv_check_metrics = lapply(1:array_dim[3], function(j){
        lapply(1:array_dim[4], function(k){
          data.frame(
            id = j,
            K = k,
            rhat = posterior::rhat(array[, , j, k]),
            ess = posterior::ess_basic(array[, , j, k]),
            ess_bulk = posterior::ess_bulk(array[, , j, k])
          )
        }) %>% do.call(rbind, .)
      }) %>%
        do.call(rbind, .)
    }
  }

  return(conv_check_metrics)
}

#' Generate AR1 serie from the incremenets and parameters
#'
#' @param E numeric matrix with random increments.
#' @param sigma numeric value with sigma parameter.
#' @param phi numeric value with phi parameter.
#'
#' @return numeric matrix with AR1 serie
#'
#' @examples
#' #
.increment_to_series = function(E, sigma, phi) {

  theta = matrix(nrow = nrow(E), ncol = ncol(E))
  theta[1, ] = (sigma/sqrt(1-(phi^2)))*E[1, ]

  for(i in 2:nrow(theta)) {
    theta[i, ] = phi*theta[i-1, ] + sigma*E[i, ]
  }

  return(theta)
}

#' Generate AR1 series from incremenets of a group stacked increments
#'
#' @param E matrix with the increments for each group stacked.
#' @param group_index numeric vector with the same size of the number of lines
#' of E. It indicates the group of the elements of E.
#' @param sigma numeric vector the sigma parameter for each group.
#' @param phi numeric vector the phi parameter for each group.
#'
#' @return numeric matrix with serie E.
#'
#' @examples
#' #
.apply_increment_to_series = function(E, group_index, sigma, phi) {
  Ng = length(unique(group_index))

  theta_matrix = lapply(1:Ng, function(g){
    sigma_group = sigma[g]
    phi_group = phi[g]
    E_group = E[group_index == g, ] %>% cbind()

    .increment_to_series(E_group, sigma_group, phi_group)

  }) %>% do.call(rbind, .)

  return(theta_matrix)
}

#' Root mean squared error
#'
#' @param x numeric vector
#' @param y numeric vector
#'
#' @return numeric vector
#'
#' @examples
#' RMSE(c(1, 2, 3), c(1, 2, 5))
.RMSE = function(x, y) {
  sqrt(mean((x-y)^2))
}

