#' Extract sample posterior from btblv_fit object
#'
#' @param btblv_fit btblv_fit object generated by `btblv_fit`.
#' @param alpha_reference alpha reference matrix for the Procrustean matching procedure.
#' It is "pca" for the pca eigenvalues applied to the logit(y), and
#' "mode" for the posterior mode, and a numeric matrix for a custom user provided.
#' Default is "pca".
#' @param apply_varimax logical value. if `TRUE`, applies a varimax transform to the reference alpha.
#' Default is `FALSE`.
#' @param add_btblv_fit logical value indicating if the object should contain the `btblv_fit` object.
#' Default is TRUE.

#'
#' @return object of the class `btblv_posterior`.
#' @export
#'
#' @examples
#' #
extract_posterior = function(btblv_fit,
                             alpha_reference = "pca",
                             apply_varimax = FALSE,
                             add_btblv_fit = FALSE) {

  assertthat::assert_that(
    "btblv_fit" %in% class(btblv_fit),
    msg = "`btblv_fit` should be an object of the class `btblv_fit."
  )

  assertthat::assert_that(
    (length(add_btblv_fit) == 1) & "logical" %in% class(add_btblv_fit),
    msg = "`add_btblv_fit` should be `TRUE` or `FALSE`."
  )

  stan_fit = btblv_fit$stan_fit
  data = btblv_fit$btblv_data
  K = data$data_list_stan$K
  precision = btblv_fit$precision

  if(is.matrix(alpha_reference) == TRUE){
    dim_alpha_ref = alpha_reference %>% dim() %>% stringr::str_flatten("-")
    dim_alpha = stan_fit@par_dims[["alpha"]] %>% stringr::str_flatten("-")

    assertthat::assert_that(
      dim_alpha_ref == dim_alpha,
      msg = "`alpha_reference` should have the same dimension of the alpha parameter."
    )
  }else if(is.character(alpha_reference) == TRUE){
    assertthat::assert_that(
      (alpha_reference %in% c("pca", "mode")),
      msg = "alpha_reference should be `pca`, `mode` or a matrix."
    )
  }

  # rotate permuted params
  post_sample = stan_fit %>% rstan::extract()

  if("matrix" %in% class(alpha_reference)) {
    reference_matrix = alpha_reference

  }else if(alpha_reference == "pca") {
    eigen_decomp = data$data_list_stan$x %>% logit %>% stats::cor() %>% base::eigen()
    reference_matrix = cbind(eigen_decomp$vectors[, 1:K])

  }else if(alpha_reference == "mode") {
    max_iter = post_sample$lp__ %>% which.max()
    reference_matrix = cbind(post_sample$alpha[max_iter,,])
  }

  if((apply_varimax == TRUE) & (btblv_fit$btblv_data$data_list_stan$K  > 1)) {
    vmax = stats::varimax(reference_matrix)
    reference_matrix = reference_matrix %*% vmax$rotmat
  }


  rotation_list = .get_rotation(post_sample$alpha, reference_matrix)

  post_sample$rot_alpha = .apply_rotation(post_sample$alpha, rotation_list)
  post_sample$rot_theta = .apply_rotation(post_sample$theta, rotation_list)
  post_sample$rot_E = .apply_rotation(post_sample$E, rotation_list)

  # rotate non permuted params
  post_sample_chains = stan_fit %>% rstan::extract(permuted = FALSE)
  chains = dim(post_sample_chains)[2]

  params = stan_fit@model_pars
  params_dims = stan_fit@par_dims

  params = params[!(params %in% c("beta_expand", "log_sigma", "kappa"))]

  if(precision == "specific") {
    params = params[params!="delta_raw"]
  }

  post_sample_chains_list = list()


  # reshape array to look similar to the permuted one
  for(param in params) {
    post_sample_chains_list[[param]] = .reshape_chain_posterior(
      post_sample_chains,
      param_name = param,
      param_dims = params_dims[[param]]
    )
  }

  # rotates for each chain
  post_sample_chains_list$rot_alpha = post_sample_chains_list$alpha
  post_sample_chains_list$rot_theta = post_sample_chains_list$theta
  post_sample_chains_list$rot_E = post_sample_chains_list$E

  for(chain in 1:chains) {

    if(K == 1) {
      alpha_array = .add_last_dimension(post_sample_chains_list$alpha[, chain, ,])
      theta_array = .add_last_dimension(post_sample_chains_list$theta[, chain, ,])
      E_array = .add_last_dimension(post_sample_chains_list$E[, chain, ,])

    }else{
      alpha_array = post_sample_chains_list$alpha[, chain, ,]
      theta_array = post_sample_chains_list$theta[, chain, ,]
      E_array = post_sample_chains_list$E[, chain, ,]
    }

    chain_rotation_list = .get_rotation(
      alpha_array,
      reference_matrix
    )

    post_sample_chains_list$rot_alpha[, chain, , ] = .apply_rotation(
      alpha_array,
      chain_rotation_list
    )

    post_sample_chains_list$rot_theta[, chain, , ] = .apply_rotation(
      theta_array,
      chain_rotation_list
    )

    post_sample_chains_list$rot_E[, chain, , ] = .apply_rotation(
      E_array,
      chain_rotation_list
    )
  }

  # creates object of the class btblv_posterior
  out = list(
    post_sample_array = post_sample,
    post_sample_chains = post_sample_chains_list,
    rotations = rotation_list,
    btblv_data = btblv_fit$btblv_data,
    precision = btblv_fit$precision,
    alpha_reference_type = alpha_reference,
    is_varimax = apply_varimax,
    alpha_reference = reference_matrix
  )

  if(add_btblv_fit == TRUE) {
    out$btblv_fit = btblv_fit
  }

  class(out) = "btblv_posterior"
  return(out)
}
