#' Extract sample posterior from btblv_fit object
#'
#' @param btblv_fit btblv_fit object generated by `btblv_fit`
#' @param add_btblv_fit logical indicating if the object should contain the btblv_fit,
#' default is TRUE
#' @return object of the class btblv_posterior
#' @export
#'
#' @examples
#' #
extract_posterior = function(btblv_fit, add_btblv_fit = FALSE) {

  stan_fit = btblv_fit$stan_fit
  data = btblv_fit$btblv_data
  K = data$data_list_stan$K
  precision = btblv_fit$precision

  # rotate permuted params
  post_sample = stan_fit %>% rstan::extract()

  eigen_decomp = data$data_list_stan$x %>% logit %>% cor() %>% eigen()
  reference_matrix = eigen_decomp$vectors[, 1:K]
  rotation_list = .get_rotation(post_sample$alpha, reference_matrix)

  post_sample$rot_alpha = .apply_rotation(post_sample$alpha, rotation_list)
  post_sample$rot_theta = .apply_rotation(post_sample$theta, rotation_list)
  post_sample$rot_E = .apply_rotation(post_sample$E, rotation_list)

  # rotate non permuted params
  post_sample_chains = stan_fit %>% rstan::extract(permuted = FALSE)
  chains = dim(post_sample_chains)[2]

  params = c("E", "theta", "alpha", "beta", "log_kappa", "phi", "sigma", "lp__")
  params_dims = stan_fit@par_dims
  post_sample_chains_list = list()

  # reshape array to look similar to the permuted one
  for(param in params) {
    post_sample_chains_list[[param]] = .reshape_chain_posterior(
      post_sample_chains,
      param_name = param,
      param_dims = params_dims[[param]]
    )
  }

  # rotates for each chain
  post_sample_chains_list$rot_alpha = post_sample_chains_list$alpha
  post_sample_chains_list$rot_theta = post_sample_chains_list$theta
  post_sample_chains_list$rot_E = post_sample_chains_list$E

  for(chain in 1:chains) {

    if(K == 1) {
      alpha_array = .add_last_dimension(post_sample_chains_list$alpha[, chain, ,])
      theta_array = .add_last_dimension(post_sample_chains_list$theta[, chain, ,])
      E_array = .add_last_dimension(post_sample_chains_list$E[, chain, ,])

    }else{
      alpha_array = post_sample_chains_list$alpha[, chain, ,]
      theta_array = post_sample_chains_list$theta[, chain, ,]
      E_array = post_sample_chains_list$E[, chain, ,]
    }

    chain_rotation_list = .get_rotation(
      alpha_array,
      reference_matrix
    )

    post_sample_chains_list$rot_alpha[, chain, , ] = .apply_rotation(
      alpha_array,
      chain_rotation_list
    )

    post_sample_chains_list$rot_theta[, chain, , ] = .apply_rotation(
      theta_array,
      chain_rotation_list
    )

    post_sample_chains_list$rot_E[, chain, , ] = .apply_rotation(
      E_array,
      chain_rotation_list
    )
  }

  # creates object of the class btblv_posterior
  out = list(
    post_sample_array = post_sample,
    post_sample_chains = post_sample_chains_list,
    rotations = rotation_list,
    btblv_data = btblv_fit$btblv_data,
    precision = btblv_fit$precision
  )

  if(add_btblv_fit == TRUE) {
    out$btblv_fit = btblv_fit
  }

  class(out) = "btblv_posterior"
  return(out)
}


